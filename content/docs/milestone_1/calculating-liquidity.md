---
title: "è®¡ç®—æµåŠ¨æ€§"
weight: 2
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

{{< katex display >}} {{</ katex >}}

# è®¡ç®—æµåŠ¨æ€§

æ²¡æœ‰æµåŠ¨æ€§å°±æ— æ³•è¿›è¡Œäº¤æ˜“ï¼Œå› æ­¤ä¸ºäº†èƒ½å¤Ÿå®Œæˆæˆ‘ä»¬çš„ç¬¬ä¸€ç¬”äº¤æ˜“ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å‘æ± å­ä¸­æ·»åŠ ä¸€äº›æµåŠ¨æ€§ã€‚ä¸ºäº†å‘æ± å­åˆçº¦æ·»åŠ æµåŠ¨æ€§ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“ï¼š

1. ä¸€ä¸ªä»·æ ¼åŒºé—´ï¼Œå³LPå¸Œæœ›ä»–çš„æµåŠ¨æ€§ä»…åœ¨è¿™ä¸ªåŒºé—´ä¸Šæä¾›å’Œè¢«åˆ©ç”¨
2. æä¾›æµåŠ¨æ€§çš„æ•°é‡ï¼Œä¹Ÿå³æä¾›çš„ä¸¤ç§ä»£å¸çš„æ•°é‡ï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒä»¬è½¬å…¥æ± å­åˆçº¦ã€‚

åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¼šæ‰‹åŠ¨è®¡ç®—ä¸Šè¿°å˜é‡çš„å€¼ï¼›åœ¨åç»­ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¼šåœ¨åˆçº¦ä¸­å¯¹æ­¤è¿›è¡Œå®ç°ã€‚é¦–å…ˆæˆ‘ä»¬æ¥è€ƒè™‘ä»·æ ¼åŒºé—´

## ä»·æ ¼åŒºé—´è®¡ç®—
å›å¿†ä¸€ä¸‹ä¸Šä¸€ç« æ‰€è®²ï¼Œåœ¨Uniswap V3ä¸­ï¼Œæ•´ä¸ªä»·æ ¼åŒºé—´è¢«åˆ’åˆ†æˆäº†ticksï¼šæ¯ä¸ªtickå¯¹åº”ä¸€ä¸ªä»·æ ¼ï¼Œä»¥åŠæœ‰ä¸€ä¸ªç¼–å·ã€‚åœ¨æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªå®ç°ä¸­ï¼Œæˆ‘ä»¬çš„ç°è´§ä»·æ ¼è®¾ç½®ä¸º1ETHå¯¹5000USDCã€‚è´­ä¹°ETHä¼šç§»é™¤æ± å­ä¸­çš„ä¸€éƒ¨åˆ†ETHï¼Œä»è€Œä½¿å¾—ä»·æ ¼å˜å¾—é«˜äº5000USDCã€‚æˆ‘ä»¬å¸Œæœ›åœ¨ä¸€ä¸ªåŒ…å«æ­¤ä»·æ ¼çš„åŒºé—´ä¸­æä¾›æµåŠ¨æ€§ï¼Œå¹¶ä¸”è¦ç¡®ä¿æœ€ç»ˆçš„ä»·æ ¼**è½åœ¨è¿™ä¸ªåŒºé—´å†…**ã€‚ï¼ˆè·¨åŒºé—´çš„äº¤æ˜“å°†ä¼šåœ¨åç»­ç« èŠ‚æåˆ°ï¼‰ã€‚

æˆ‘ä»¬éœ€è¦æ‰¾åˆ°3ä¸ªtickï¼š
1. å¯¹åº”ç°è´§ä»·æ ¼çš„tickï¼ˆ1ETH-5000USDCï¼‰
2. æä¾›æµåŠ¨æ€§çš„ä»·æ ¼åŒºé—´ä¸Šä¸‹ç•Œå¯¹åº”çš„tickã€‚åœ¨è¿™é‡Œï¼Œä¸‹ç•Œä¸º4545uï¼Œä¸Šç•Œä¸º5500uã€‚

ï¼ˆè¯‘è€…æ³¨ï¼š4545uï¼Œ$4545ï¼Œ4545USDCå‡ä»£è¡¨ç›¸åŒå«ä¹‰ï¼Œåœ¨æœ¬ä¹¦ä¸­å¯èƒ½ä¼šæ··åˆä½¿ç”¨ï¼‰

ä»ä¹‹å‰çš„ç« èŠ‚ä¸­æˆ‘ä»¬çŸ¥é“ä¸‹è¿°å…¬å¼ï¼š

$$\sqrt{P} = \sqrt{\frac{y}{x}}$$

ç”±äºæˆ‘ä»¬æŠŠETHä½œä¸ºèµ„äº§$x$ï¼ŒUSDCä½œä¸ºèµ„äº§$y$ï¼Œæ¯ä¸ªtickå¯¹åº”çš„å€¼ä¸ºï¼š


$$\sqrt{P_c} = \sqrt{\frac{5000}{1}} = \sqrt{5000} \approx 70.71$$

$$\sqrt{P_l} = \sqrt{\frac{4545}{1}} \approx 67.42$$

$$\sqrt{P_u} = \sqrt{\frac{5500}{1}} \approx 74.16$$

åœ¨è¿™é‡Œï¼Œ$P_c$ä»£è¡¨ç°è´§ä»·æ ¼ï¼Œ$P_l$ä»£è¡¨åŒºé—´ä¸‹ç•Œï¼Œ$P_u$ä»£è¡¨åŒºé—´ä¸Šç•Œã€‚

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ä»·æ ¼å¯¹åº”çš„ticksã€‚ä½¿ç”¨ä¸‹é¢å…¬å¼ï¼š

$$\sqrt{P(i)}=1.0001^{\frac{i}{2}}$$

æˆ‘ä»¬å¯ä»¥å¾—åˆ°å…³äº$i$çš„å…¬å¼ï¼š

$$i = log_{\sqrt{1.0001}} \sqrt{P(i)}$$

> å…¬å¼ä¸­çš„ä¸¤ä¸ªæ ¹å·å®é™…ä¸Šæ˜¯å¯ä»¥æ¶ˆå»çš„ï¼Œä½†ç”±äºæˆ‘ä»¬ä¼šä½¿ç”¨$\sqrt{p}$è¿›è¡Œè®¡ç®—ï¼Œæˆ‘ä»¬é€‰æ‹©ä¿ç•™æ ¹å·

è¿™å‡ ä¸ªå¯¹åº”çš„tickåˆ†åˆ«ä¸º:
1. ç°è´§tick: $i_c = log_{\sqrt{1.0001}} 70.71 = 85176$
2. ä¸‹ç•Œtick: $i_l = log_{\sqrt{1.0001}} 67.42 = 84222$
3. ä¸Šç•Œtick: $i_u = log_{\sqrt{1.0001}} 74.16 = 86129$

> è®¡ç®—è¿‡ç¨‹ä½¿ç”¨çš„æ˜¯Pythonï¼š
> ```python
> import math
>
> def price_to_tick(p):
>     return math.floor(math.log(p, 1.0001))
>
> price_to_tick(5000)
> > 85176
>```

ä»·æ ¼åŒºé—´çš„è®¡ç®—å°±æ˜¯è¿™æ ·ï¼

æœ€åéœ€è¦æåˆ°çš„æ˜¯ï¼Œåœ¨Solidityä¸­ï¼ŒUniswapä½¿ç”¨Q64.96æ¥å­˜å‚¨$\sqrt{p}$ã€‚è¿™æ˜¯ä¸€ä¸ªæ•´æ•°ä½ç”±64ä½è¡¨ç¤ºã€å°æ•°ä½ç”±96ä½è¡¨ç¤ºçš„å®šç‚¹æ•°æ ¼å¼ã€‚åœ¨æˆ‘ä»¬ä¸Šé¢çš„è®¡ç®—ä¸­ï¼Œä»·æ ¼æŒ‰ç…§æµ®ç‚¹æ•°å½¢å¼è®¡ç®—ï¼š`70.71`, `67.42`, `74.16`ã€‚æˆ‘ä»¬éœ€è¦å°†å®ƒä»¬è½¬æ¢æˆQ64.96æ ¼å¼ï¼Œä¹Ÿéå¸¸ç®€å•ï¼šåªéœ€è¦å°†è¿™ä¸ªæ•°ä¹˜ä»¥$2^{96}$ï¼Œå³å¯å¾—åˆ°ï¼š

$$\sqrt{P_c} = 5602277097478614198912276234240$$

$$\sqrt{P_l} = 5314786713428871004159001755648$$

$$\sqrt{P_u} = 5875717789736564987741329162240$$

> åœ¨Pythonä¸­ï¼š
> ```python
> q96 = 2**96
> def price_to_sqrtp(p):
>     return int(math.sqrt(p) * q96)
>
> price_to_sqrtp(5000)
> > 5602277097478614198912276234240
> ```
> Notice that we're multiplying before converting to integer. Otherwise, we'll lose precision.


## Token Amounts Calculation

Next step is to decide how many tokens we want to deposit into the pool. The answer is: as many as we want. The amounts
are not strictly defined, we can deposit as much as it is enough to buy a small amount of ETH without making the current
price leave the price range we put liquidity into. During development and testing we'll be able to mint any amount of tokens,
so getting the amounts we want is not a problem.

For our first swap, let's deposit 1 ETH and 5000 USDC.

> Recall that the proportion of current pool reserves tells the current spot price. So if we want to put more tokens into
the pool and keep the same price, the amounts must be proportional, e.g.: 2 ETH and 10,000 USDC; 10 ETH and 500,000 USDC, etc.

## Liquidity Amount Calculation

Next, we need to calculate $L$ based on the amounts we'll deposit. This is a tricky part, so hold tight!

From the theoretical introduction, you remember that:
$$L = \sqrt{xy}$$

However, this formula is for the infinite curve ğŸ™‚ But we want to put liquidity into a limited price range, which is just
a segment of that infinite curve. We need to calculate $L$ specifically for the price range we're going to deposit liquidity
into. We need some more advanced calculations.

To calculate $L$ for a price range, let's look at one interesting fact we have discussed earlier: price ranges can be
depleted. It's absolutely possible to buy the entire amount of one token from a price range and leave the pool with only
the other token.

![Range depletion example](/images/milestone_1/range_depleted.png)

At the points $a$ and $b$, there's only one token in the range: ETH at the point $a$ and USDC at the point $b$.

That being said, we want to find an $L$ that will allow the price to move to either of the points. We want enough
liquidity for the price to reach either of the boundaries of a price range. Thus, we want $L$ to be calculated based on
the maximum amounts of $\Delta x$ and $\Delta y$.

Now, let's see what the prices are at the edges. When ETH is bought from a pool, the price is growing; when USDC is bought,
the price is falling. Recall that the price is $\frac{y}{x}$. So, at the point $a$, the price is lowest of the range;
at the point $b$, the price is highest.

>In fact, prices are not defined at these points because there's only one reserve in the pool, but what we need to
understand here is that the price around the point $b$ is higher than the start price, and the price at the point $a$ is
lower than the start price.

Now, break the curve from the image above into two segments: one to the left of the start point and one to the right of
the start point. We're going to calculate **two** $L$'s, one for each of the segments. Why? Because each of the two
tokens of a pool contributes to **either of the segments**. And since we want to distribute liquidity evenly along the
entire curve, we want to pick the minimal of the two $L$'s.


![Liquidity on the curve](/images/milestone_1/curve_liquidity.png)

And the final detail I need to focus your attention on here is: **new liquidity must not change the current price**. That
is, it must be proportional to the current proportion of the reserves. And this is why the two $L$'s can be differentâ€“when
the proportion is not preserved. And we pick the small $L$ to reestablish the proportion.

I hope this will make more sense after we implement this in code! Now, let's look at the formulas.

Let's recall how $\Delta x$ and $\Delta y$ are calculated:

$$\Delta x = \Delta \frac{1}{\sqrt{P}} L$$
$$\Delta y = \Delta \sqrt{P} L$$

We can expands these formulas by replacing the delta P's with actual prices (we know them from the above):

$$\Delta x = (\frac{1}{\sqrt{P_b}} - \frac{1}{\sqrt{P_c}}) L$$
$$\Delta y = (\sqrt{P_c} - \sqrt{P_a}) L$$

$P_a$ is the price at the point $a$, $P_b$ is the price at the point $b$, and $P_c$ is the current price.

Let's find the $L$ from the first formula:

$$\Delta x = (\frac{1}{\sqrt{P_b}} - \frac{1}{\sqrt{P_c}}) L$$
$$\Delta x = \frac{L}{\sqrt{P_b}} - \frac{L}{\sqrt{P_c}}$$
$$\Delta x = \frac{L(\sqrt{P_b} - \sqrt{P_c})}{\sqrt{P_b} \sqrt{P_c}}$$
$$L = \Delta x \frac{\sqrt{P_b} \sqrt{P_c}}{\sqrt{P_b} - \sqrt{P_c}}$$

And from the second formula:
$$\Delta y = (\sqrt{P_c} - \sqrt{P_a}) L$$
$$L = \frac{\Delta y}{\sqrt{P_c} - \sqrt{P_a}}$$

So, these are our two $L$'s, one for each of the segments:

$$L = \Delta x \frac{\sqrt{P_b} \sqrt{P_c}}{\sqrt{P_b} - \sqrt{P_c}}$$
$$L = \frac{\Delta y}{\sqrt{P_c} - \sqrt{P_a}}$$


Now, let's plug the prices we calculated earlier into them:

$$L = \Delta x \frac{\sqrt{P_b}\sqrt{P_c}}{\sqrt{P_b}-\sqrt{P_c}} = 1 ETH * \frac{67.42 * 70.71}{70.71 - 67.42}$$
After converting to Q64.96, we get:

$$L = 1519437308014769733632$$

And for the other $L$:
$$L = \frac{\Delta y}{\sqrt{P_c}-\sqrt{P_a}} = \frac{5000USDC}{74.16-70.71}$$
$$L = 1517882343751509868544$$

Of these two, we'll pick the smaller one.

> In Python:
> ```python
> sqrtp_low = price_to_sqrtp(4545)
> sqrtp_cur = price_to_sqrtp(5000)
> sqrtp_upp = price_to_sqrtp(5500)
> 
> def liquidity0(amount, pa, pb):
>     if pa > pb:
>         pa, pb = pb, pa
>     return (amount * (pa * pb) / q96) / (pb - pa)
>
> def liquidity1(amount, pa, pb):
>     if pa > pb:
>         pa, pb = pb, pa
>     return amount * q96 / (pb - pa)
> 
> liq0 = liquidity0(amount_eth, sqrtp_cur, sqrtp_upp)
> liq1 = liquidity1(amount_usdc, sqrtp_cur, sqrtp_low)
> liq = int(min(liq0, liq1))
> > 1517882343751509868544
> ```

## Token Amounts Calculation, Again

Since we choose the amounts we're going to deposit, the amounts can be wrong. We cannot deposit any amounts at any price
ranges; liquidity amount needs to be distributed evenly along the curve of the price range we're depositing into. Thus, even
though users choose amounts, the contract needs to re-calculate them, and actual amounts will be slightly different (at
least because of rounding).

Luckily, we already know the formulas:

$$\Delta x = \frac{L(\sqrt{P_b} - \sqrt{P_c})}{\sqrt{P_b} \sqrt{P_c}}$$
$$\Delta y = L(\sqrt{P_c} - \sqrt{P_a})$$

> In Python:
> ```python
> def calc_amount0(liq, pa, pb):
>     if pa > pb:
>         pa, pb = pb, pa
>     return int(liq * q96 * (pb - pa) / pa / pb)
> 
> 
> def calc_amount1(liq, pa, pb):
>     if pa > pb:
>         pa, pb = pb, pa
>     return int(liq * (pb - pa) / q96)
>
> amount0 = calc_amount0(liq, sqrtp_upp, sqrtp_cur)
> amount1 = calc_amount1(liq, sqrtp_low, sqrtp_cur)
> (amount0, amount1)
> > (998976618347425408, 5000000000000000000000)
> ```
> As you can see, the number are close to the amounts we want to provide, but ETH is slightly smaller.

> **Hint**: use `cast --from-wei AMOUNT` to convert from wei to ether, e.g.:  
> `cast --from-wei 998976618347425280` will give you `0.998976618347425280`.